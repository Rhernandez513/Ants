#include<time.h>
struct Block{
	bool full;
	Ant* a;
	
	
};
class Kitchen
{
private:
	int width, height;

	int nblue, nred;
	int nummoves;
	bool turn;//false for red, true for blue
	Block** Field;
	vector<Ant*> blueTeam, redTeam;

public:

	Kitchen(int width, int height, int n, int nblue, int nred)
	{

		srand(time(NULL));
		this->width = width;
		this->height = height;
		turn = false;
		this->nummoves = n;
		this->nred = nred;
		this->nblue = nblue;
		Field = new Block*[height];
		for (int i = 0; i < height; i++)
		{
			Field[i]=new Block[width];
		}
		
		//randomly fill field right side
		int i = 0, x, y;

		while (i < nblue)
		{

			x = rand() % width / 2;
			y = rand() % height;
			if (i == 0)
			{
				Field[x + width / 2][y].full = true;
				Field[x + width / 2][y].a = new Ant(Color::Blue, Heirarchy::Queen);
				i++;
				continue;
			}

			if (Field[x + width / 2][y].full)
				continue;


			Field[x + width / 2][y].full = true;
			if (i % 3 == 0)
				Field[x + width / 2][y].a = new Ant(Color::Blue, Heirarchy::Worker);
			if (i % 3 == 1)
				Field[x + width / 2][y].a = new Ant(Color::Blue, Heirarchy::Soldier);
			if (i % 3 == 2)
				Field[x + width / 2][y].a = new Ant(Color::Blue, Heirarchy::Knight);
			i++;

		}

		while (i < nred)
		{

			x = rand() % width / 2;
			y = rand() % height;
			if (i == 0)
			{
				Field[x][y].full = true;
				Field[x][y].a = new Ant(Color::Red, Heirarchy::Queen);
				i++;
				continue;
			}

			if (Field[x][y].full)
				continue;


			Field[x][y].full = true;
			if (i % 3 == 0)
				Field[x][y].a = new Ant(Color::Red, Heirarchy::Worker);
			if (i % 3 == 1)
				Field[x][y].a = new Ant(Color::Red, Heirarchy::Soldier);
			if (i % 3 == 2)
				Field[x][y].a = new Ant(Color::Red, Heirarchy::Knight);
			i++;

		}
	}
		bool move(int x1, int y1, int x2, int y2)// return 1 if successful
		{//this function moves an ant from position [x1][y1] to [x2][y2]
			if ((!Field[x1][y1].full) || Field[x2][y2].full)
				return false;

			Field[x2][y2].a = Field[x1][y1].a;
			Field[x1][y1].a = nullptr; //emptying the first position
			Field[x2][y2].full= true;
			Field[x1][y1].full = false;
			return true;
			
		}

		bool action(int x, int y)//return 1 if successful
		{
			int adj[3][3];
			int res = 0; // zero if no ant was killed, 1 if ant A was killed, 2 if ant b was killed
			bool blocked = true;
			//array of adjacent cells, -1 -> out of bounds,0-> empty, 1-> friendly, 2-> enemy
			for (int i = -1; i < 2; i++)
			{
				for (int j = -1; j < 2; j++)
				{
					if (x + i<0 || x + i>width || y + j<0 || y + j>height)
					{
						adj[i + 1][j + 1] = -1;
						i++;
						continue;
					}
					if (!Field[x + i][y + j].full)
					{
						adj[i + 1][j + 1] = 0;
						blocked = false;
					}
					else{
						
						if (Field[x][y].a->color == Field[x + i][y + j].a->color)
						{
							adj[i + 1][j + 1] = 1;
						}
						else
						{
							adj[i + 1][j + 1] = 2;
							blocked = false;
						}
					}
				}
				if (blocked)
					return false;
				
				int r1 = rand() % 3, r2 = rand() % 3;//choose a random spot
				r1--;
				r2--;
				// random generator; if friendly ant or out of bounds redo random generator
				while ((r1 == 0 && r2 == 0) || adj[r1][r2] == -1 || adj[r1][r2] == 1)// if chosen spot is (0,0), chosen spot is out of bounds or friendly
				{

					r1 = rand() % 3, r2 = rand() % 3;//choose again
					r1--;
					r2--;
				}
				if (adj[r1][r2] == 0)// if spot is empty
				{//movement
				move(x,y,x+r1,y+r2); //move ant from x,y to x+r1, y+r2


				}
				else//spot has enemy
				{
					res=combat(Field[x][y].a, Field[x + r1][y + r2].a);
					if (res==1)//to be continued
				}
				}

			}
		}
	}
